package database

import (
	"context"
	"encoding/base32"
	"strings"
	"time"

	"gitlab.com/NebulousLabs/errors"
	"gitlab.com/NebulousLabs/fastrand"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

/**
API keys are authentication tokens generated by users. They do not expire, thus
allowing users to use them for a long time and to embed them in apps and on
machines. API keys can be revoked when they are no longer needed or if they get
compromised. This is done by deleting them from this service.
*/

var (
	// MaxNumAPIKeysPerUser sets the limit for number of API keys a single user
	// can create. If a user reaches that limit they can always delete some API
	// keys in order to make space for new ones. This value is configurable via
	// the ACCOUNTS_MAX_NUM_API_KEYS_PER_USER environment variable.
	MaxNumAPIKeysPerUser = 1000
	// ErrMaxNumAPIKeysExceeded is returned when a user tries to create a new
	// API key after already having the maximum allowed number.
	ErrMaxNumAPIKeysExceeded = errors.New("maximum number of api keys exceeded")
)

type (
	// APIKey is a base32hex-encoded-no-padding representation of []byte with
	// length PubKeySize
	APIKey string
	// APIKeyRecord is a non-expiring authentication token generated on user demand.
	APIKeyRecord struct {
		ID        primitive.ObjectID `bson:"_id,omitempty" json:"id"`
		UserID    primitive.ObjectID `bson:"user_id" json:"-"`
		Key       APIKey             `bson:"key" json:"-"`
		CreatedAt time.Time          `bson:"created_at" json:"createdAt"`
	}
)

// New creates a random new API key.
func NewAPIKey() APIKey {
	return APIKey(base32.HexEncoding.WithPadding(base32.NoPadding).EncodeToString(fastrand.Bytes(PubKeySize)))
}

// Bytes defines the way we decode an API key.
func (ak APIKey) Bytes() ([]byte, error) {
	return base32.HexEncoding.WithPadding(base32.NoPadding).DecodeString(strings.ToUpper(string(ak)))
}

// IsValid checks whether the underlying string satisfies the type's requirement
// to represent a []byte with length PubKeySize which is encoded as base32 with
// no padding.
// This method does NOT check whether the API exists in the database.
func (ak APIKey) IsValid() bool {
	b, err := ak.Bytes()
	return err == nil && len(b) == PubKeySize
}

// LoadBytes encodes a []byte of size PubKeySize into an API key.
func (ak *APIKey) LoadBytes(b []byte) error {
	if len(b) != PubKeySize {
		return errors.New("key too short")
	}
	*ak = APIKey(base32.HexEncoding.WithPadding(base32.NoPadding).EncodeToString(b))
	return nil
}

// APIKeyCreate creates a new API key.
func (db *DB) APIKeyCreate(ctx context.Context, user User) (*APIKeyRecord, error) {
	if user.ID.IsZero() {
		return nil, errors.New("invalid user")
	}
	n, err := db.staticAPIKeys.CountDocuments(ctx, bson.M{"user_id": user.ID})
	if err != nil {
		return nil, errors.AddContext(err, "failed to ensure user can create a new API key")
	}
	if n > int64(MaxNumAPIKeysPerUser) {
		return nil, ErrMaxNumAPIKeysExceeded
	}
	akr := APIKeyRecord{
		UserID:    user.ID,
		Key:       NewAPIKey(),
		CreatedAt: time.Now().UTC(),
	}
	ior, err := db.staticAPIKeys.InsertOne(ctx, akr)
	if err != nil {
		return nil, err
	}
	akr.ID = ior.InsertedID.(primitive.ObjectID)
	return &akr, nil
}

// APIKeyDelete deletes an API key.
func (db *DB) APIKeyDelete(ctx context.Context, user User, akID string) error {
	if user.ID.IsZero() {
		return errors.New("invalid user")
	}
	id, err := primitive.ObjectIDFromHex(akID)
	if err != nil {
		return errors.AddContext(err, "invalid API key ID")
	}
	filter := bson.M{
		"_id":     id,
		"user_id": user.ID,
	}
	dr, err := db.staticAPIKeys.DeleteOne(ctx, filter)
	if err != nil {
		return err
	}
	if dr.DeletedCount == 0 {
		return mongo.ErrNoDocuments
	}
	return nil
}

// APIKeyList lists all API keys that belong to the user.
func (db *DB) APIKeyList(ctx context.Context, user User) ([]APIKeyRecord, error) {
	if user.ID.IsZero() {
		return nil, errors.New("invalid user")
	}
	c, err := db.staticAPIKeys.Find(ctx, bson.M{"user_id": user.ID})
	if err != nil {
		return nil, err
	}
	// We want this to be a make in order to make sure its JSON representation
	// is a valid JSONArray and not a null.
	aks := make([]APIKeyRecord, 0)
	err = c.All(ctx, &aks)
	if err != nil {
		return nil, err
	}
	return aks, nil
}
