package database

import (
	"context"
	"encoding/base32"
	"fmt"
	"strings"
	"time"

	"gitlab.com/NebulousLabs/errors"
	"gitlab.com/NebulousLabs/fastrand"
	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
)

/**
API keys are authentication tokens generated by users. They do not expire, thus
allowing users to use them for a long time and to embed them in apps and on
machines. API keys can be revoked when they are no longer needed or if they get
compromised. This is done by deleting them from this service.
*/

var (
	// MaxNumAPIKeysPerUser sets the limit for number of API keys a single user
	// can create. If a user reaches that limit they can always delete some API
	// keys in order to make space for new ones. This value is configurable via
	// the ACCOUNTS_MAX_NUM_API_KEYS_PER_USER environment variable.
	MaxNumAPIKeysPerUser = 1000
	// ErrMaxNumAPIKeysExceeded is returned when a user tries to create a new
	// API key after already having the maximum allowed number.
	ErrMaxNumAPIKeysExceeded = errors.New("maximum number of api keys exceeded")
	// ErrInvalidAPIKey is an error returned when the given API key is invalid.
	ErrInvalidAPIKey = errors.New("invalid api key")
)

type (
	// APIKey is the hex representation of a base32-encoded random 32-byte slice
	// length PubKeySize
	APIKey string
	// APIKeyRecord is a non-expiring authentication token generated on user demand.
	APIKeyRecord struct {
		ID        primitive.ObjectID `bson:"_id,omitempty" json:"id"`
		UserID    primitive.ObjectID `bson:"user_id" json:"-"`
		Key       APIKey             `bson:"key" json:"-"`
		CreatedAt time.Time          `bson:"created_at" json:"createdAt"`
	}
)

// NewAPIKey creates a random new API key.
func NewAPIKey() APIKey {
	return APIKey(base32.HexEncoding.WithPadding(base32.NoPadding).EncodeToString(fastrand.Bytes(PubKeySize)))
}

// NewAPIKeyFromString creates an APIKey struct from a string and validates it.
func NewAPIKeyFromString(s string) (*APIKey, error) {
	ak := APIKey(strings.ToUpper(s))
	if !ak.IsValid() {
		return nil, ErrInvalidAPIKey
	}
	return &ak, nil
}

// Bytes returns the raw representation of an API key.
func (ak APIKey) Bytes() ([]byte, error) {
	return base32.HexEncoding.WithPadding(base32.NoPadding).DecodeString(string(ak))
}

// IsValid checks whether the underlying string satisfies the type's requirement
// to represent a []byte with length PubKeySize which is encoded as base32 with
// no padding.
// This method does NOT check whether the API exists in the database.
func (ak APIKey) IsValid() bool {
	b, err := ak.Bytes()
	return err == nil && len(b) == PubKeySize
}

// LoadBytes encodes a []byte of size PubKeySize into an API key.
func (ak *APIKey) LoadBytes(b []byte) error {
	if len(b) != PubKeySize {
		return errors.New(fmt.Sprintf("unexpected API key size, %d != %d", len(b), PubKeySize))
	}
	*ak = APIKey(base32.HexEncoding.WithPadding(base32.NoPadding).EncodeToString(b))
	return nil
}

// APIKeyCreate creates a new API key.
func (db *DB) APIKeyCreate(ctx context.Context, user User) (*APIKeyRecord, error) {
	if user.ID.IsZero() {
		return nil, errors.New("invalid user")
	}
	n, err := db.staticAPIKeys.CountDocuments(ctx, bson.M{"user_id": user.ID})
	if err != nil {
		return nil, errors.AddContext(err, "failed to ensure user can create a new API key")
	}
	if n > int64(MaxNumAPIKeysPerUser) {
		return nil, ErrMaxNumAPIKeysExceeded
	}
	akr := APIKeyRecord{
		UserID:    user.ID,
		Key:       NewAPIKey(),
		CreatedAt: time.Now().UTC(),
	}
	ior, err := db.staticAPIKeys.InsertOne(ctx, akr)
	if err != nil {
		return nil, err
	}
	akr.ID = ior.InsertedID.(primitive.ObjectID)
	return &akr, nil
}

// APIKeyDelete deletes an API key.
func (db *DB) APIKeyDelete(ctx context.Context, user User, akID string) error {
	if user.ID.IsZero() {
		return errors.New("invalid user")
	}
	id, err := primitive.ObjectIDFromHex(akID)
	if err != nil {
		return errors.AddContext(err, "invalid API key ID")
	}
	filter := bson.M{
		"_id":     id,
		"user_id": user.ID,
	}
	dr, err := db.staticAPIKeys.DeleteOne(ctx, filter)
	if err != nil {
		return err
	}
	if dr.DeletedCount == 0 {
		return mongo.ErrNoDocuments
	}
	return nil
}

// APIKeyList lists all API keys that belong to the user.
func (db *DB) APIKeyList(ctx context.Context, user User) ([]APIKeyRecord, error) {
	if user.ID.IsZero() {
		return nil, errors.New("invalid user")
	}
	c, err := db.staticAPIKeys.Find(ctx, bson.M{"user_id": user.ID})
	if err != nil {
		return nil, err
	}
	// We want this to be a make in order to make sure its JSON representation
	// is a valid JSONArray and not a null.
	aks := make([]APIKeyRecord, 0)
	err = c.All(ctx, &aks)
	if err != nil {
		return nil, err
	}
	return aks, nil
}
